# Pintor - Write Ahead Log Implementation

A robust Java implementation of a Write Ahead Log (WAL) system designed for ensuring data durability and consistency in
database systems.

*This code is primarily generated by Amazon Q Developer, showcasing AI-assisted software development. From initial architecture design to comprehensive test suites. This project demonstrates the power of AI in generating complex, well-documented, and thoroughly tested software systems.*

## Features

- **Thread-safe operations** - eliminates race conditions in multi-threaded environments
- **File-based persistence** with automatic file rotation
- **Binary serialization** with CRC32 checksum for data integrity
- **Recovery capabilities** after system crashes
- **Batch operations** for improved performance (both single and batch APIs)
- **Configurable sync behavior** (sync on write or manual sync)
- **Range-based reading** for efficient log replay (by sequence number or timestamp)
- **Point-in-time recovery** with timestamp-based queries
- **Log truncation** for space management
- **Generic record types** - users can define custom record types
- **Persistent sequence numbers** - always incrementing even after restart
- **Clean encapsulation** - WAL manages all sequence numbers and timestamps automatically

## Architecture

### Core Components

1. **WALEntry** - Simple POJO representing individual log entries
2. **WriteAheadLog** - Interface defining the contract for WAL implementations
3. **FileBasedWAL** - File-based implementation with binary serialization and CRC32 validation
4. **WALManager** - High-level manager providing convenience methods and thread-safe operations
5. **WALException** - Custom exception for WAL operations

### Thread Safety

All operations are **fully thread-safe**:
- **Atomic entry creation** - `createEntry()` and `createEntryBatch()` methods handle sequence number generation atomically
- **No race conditions** - Sequence numbers are generated and entries are appended in a single atomic operation
- **Concurrent access** - Multiple threads can safely create entries simultaneously
- **ReadWriteLock protection** - All operations use appropriate locking for thread safety
- **Encapsulated metadata** - WAL automatically manages sequence numbers and timestamps

### File Structure and Storage

### Files Created

The WAL implementation creates the following files in the specified directory:

1. **WAL Log Files**: `wal-{index}.log`
   - Contains the actual WAL entries in binary format
   - Automatically rotated when size limit is reached (default: 64MB)
   - Examples: `wal-0.log`, `wal-1.log`, `wal-2.log`

2. **Sequence File**: `sequence.dat`
   - Stores the current sequence number for crash recovery
   - 8 bytes containing the last written sequence number
   - Updated after each successful write operation

### WAL Entry Binary Format

Each WAL entry is stored in a compact binary format with the following structure:

```
┌─────────────────┬──────────────────┬─────────────────┬─────────────────┬──────────────┬─────────────┐
│ Sequence Number │ Timestamp (sec)  │ Timestamp (ns)  │ Data Length     │ Data Payload │ CRC32       │
│ 8 bytes         │ 8 bytes          │ 4 bytes         │ 4 bytes         │ variable     │ 4 bytes     │
└─────────────────┴──────────────────┴─────────────────┴─────────────────┴──────────────┴─────────────┘
```

**Field Details:**

- **Sequence Number** (8 bytes, long) - Monotonically increasing identifier, automatically managed by WAL
- **Timestamp Seconds** (8 bytes, long) - Unix epoch seconds when entry was created, automatically set by WAL
- **Timestamp Nanoseconds** (4 bytes, int) - Nanosecond precision for timestamp, automatically set by WAL
- **Data Length** (4 bytes, int) - Length of the data payload (0 if no data)
- **Data Payload** (variable bytes) - Application-specific data containing record types, transaction IDs, and business data
- **CRC32 Checksum** (4 bytes, int) - Integrity checksum calculated over all preceding fields

### Log File Format

Each log file contains WAL entries stored sequentially with the following structure:

```
┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│ WAL Entry       │ WAL Entry       │ WAL Entry       │ ...             │
│ variable        │ variable        │ variable        │                 │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

- **WAL Entry** (variable bytes) - The binary-serialized WAL entry as described above

### Efficient Seeking Algorithm

When reading from a given sequence number, the WAL uses an efficient seeking algorithm:

1. **Read sequence number** (8 bytes) and compare with target
2. **If not matched**: 
   - Read timestamp fields (12 bytes total)
   - Read data length field (4 bytes)
   - **Skip to next record**: current_position + 24 + data_length + 4 (CRC32)
3. **If matched**: Read the complete entry for processing

This allows fast traversal through the log without deserializing unwanted entries.

### Storage Characteristics

- **Endianness**: All multi-byte values are stored in big-endian format (Java default)
- **Alignment**: No padding or alignment - entries are packed sequentially
- **Integrity**: Each entry includes a CRC32 checksum for corruption detection
- **Atomicity**: Individual entries are written atomically
- **Compactness**: 28 bytes overhead per entry (sequence + timestamps + data length + CRC32)

## Usage

### Thread-Safe Entry Creation

```java
try (WALManager walManager = new WALManager(Paths.get("/path/to/wal"))) {
    // Thread-safe single entry creation - WAL automatically assigns sequence numbers and timestamps
    String insertData = "INSERT|txn_1001|users|1|{\"name\":\"John\",\"email\":\"john@example.com\"}";
    WALEntry entry1 = walManager.createEntry(insertData.getBytes());
    
    String updateData = "UPDATE|txn_1001|users|1|{\"name\":\"John Doe\",\"email\":\"john@example.com\"}";
    WALEntry entry2 = walManager.createEntry(updateData.getBytes());
    
    // Force sync to disk
    walManager.sync();
}
```

### Batch Operations

```java
try (WALManager walManager = new WALManager(walDir)) {
    // Create multiple entries atomically with consecutive sequence numbers
    List<byte[]> dataList = Arrays.asList(
        "BEGIN|txn_2001|".getBytes(),
        "INSERT|txn_2001|products|1|{\"name\":\"Laptop\",\"price\":999.99}".getBytes(),
        "INSERT|txn_2001|products|2|{\"name\":\"Mouse\",\"price\":29.99}".getBytes(),
        "COMMIT|txn_2001|".getBytes()
    );
    
    List<WALEntry> entries = walManager.createEntryBatchFromBytes(dataList);
    
    // All entries will have consecutive sequence numbers automatically assigned
    // and are created atomically (thread-safe)
    System.out.println("Created entries with sequence numbers: " + 
        entries.stream().mapToLong(WALEntry::getSequenceNumber).boxed().toList());
}
```

### Advanced Usage with FileBasedWAL Direct Access

```java
try (FileBasedWAL wal = new FileBasedWAL(walDir)) {
    // Direct access to FileBasedWAL for advanced scenarios
    WALEntry entry1 = wal.createAndAppend(ByteBuffer.wrap("BEGIN|txn_4001|".getBytes()));
    WALEntry entry2 = wal.createAndAppend(ByteBuffer.wrap("INSERT|txn_4001|data1".getBytes()));
    WALEntry entry3 = wal.createAndAppend(ByteBuffer.wrap("UPDATE|txn_4001|data2".getBytes()));
    WALEntry entry4 = wal.createAndAppend(ByteBuffer.wrap("COMMIT|txn_4001|".getBytes()));
    
    // All entries will have consecutive sequence numbers
    // and are created atomically (thread-safe)
}
```

### Concurrent Operations

```java
// Multiple threads can safely create entries simultaneously
ExecutorService executor = Executors.newFixedThreadPool(10);

for (int i = 0; i < 100; i++) {
    final int threadId = i;
    executor.submit(() -> {
        try {
            // Thread-safe - no race conditions, sequence numbers automatically managed
            WALEntry entry = walManager.createEntry(("thread_" + threadId + "_data").getBytes());
            // Each entry will have a unique, consecutive sequence number
            System.out.println("Thread " + threadId + " created entry with sequence: " + entry.getSequenceNumber());
        } catch (WALException e) {
            // Handle error
        }
    });
}
```

### Reading from WAL and Point-in-Time Recovery

```java
// Read all entries from sequence 0
List<WALEntry> allEntries = walManager.readFrom(0L);

// Read entries in a specific sequence range
List<WALEntry> rangeEntries = walManager.readRange(10L, 20L);

// Read entries from a specific timestamp (point-in-time recovery)
Instant recoveryPoint = Instant.parse("2023-12-01T10:30:00Z");
List<WALEntry> entriesFromTime = walManager.readFrom(recoveryPoint);

// Read entries in a specific timestamp range
Instant startTime = Instant.parse("2023-12-01T10:00:00Z");
Instant endTime = Instant.parse("2023-12-01T11:00:00Z");
List<WALEntry> timeRangeEntries = walManager.readRange(startTime, endTime);

// Application-specific - filter by transaction ID
long targetTxnId = 2001L;
List<WALEntry> txnEntries = allEntries.stream()
    .filter(entry -> {
        String data = new String(entry.getDataAsBytes());
        return data.contains("txn_" + targetTxnId);
    })
    .collect(Collectors.toList());
```

### Recovery

The WAL automatically recovers the last sequence number and entry count when reopened:

```java
// First session
try (WALManager walManager = new WALManager(walDir)) {
    WALEntry entry = walManager.createEntry("data".getBytes());
    // Application crashes here
}

// Second session - automatic recovery
try (WALManager walManager = new WALManager(walDir)) {
    // Automatically recovers last sequence number
    long lastSeq = walManager.getCurrentSequenceNumber();
    long nextSeq = walManager.getNextSequenceNumber(); // Always incrementing
    // Continue operations with proper sequence number continuation
    WALEntry newEntry = walManager.createEntry("recovered_data".getBytes());
    System.out.println("New entry sequence: " + newEntry.getSequenceNumber()); // Will be lastSeq + 1
}
```

## WAL Entry Structure

Each WAL entry is a simple POJO containing:
- **Sequence Number** (long) - Always incrementing, automatically managed by WAL, persisted across restarts
- **Timestamp** (Instant) - When the entry was created, automatically set by WAL (for point-in-time recovery)
- **Data** (ByteBuffer) - Application-specific data containing record types, transaction IDs, and business data

## File Format

The WAL uses a binary file format with CRC32 checksums:

- **Log Files**: `wal-{index}.log` containing binary entries with length prefixes
- **Sequence File**: `sequence.dat` storing the current sequence number (8 bytes)
- **CRC32 checksums** ensure data integrity and detect corruption
- **Automatic file rotation** when files exceed the configured size limit
- **Sequential access pattern** optimized for write performance

## Configuration

```java
// Custom configuration
FileBasedWAL wal = new FileBasedWAL(
    walDirectory,
    64 * 1024 * 1024,  // 64MB max file size
    true               // sync on write
);

// Or use WALManager with default settings
WALManager walManager = new WALManager(walDirectory);
```

## Testing

Run the comprehensive test suite:

```bash
./gradlew test
```

## Thread Safety

All operations are thread-safe using ReadWriteLock and atomic operations:

- **Entry creation** (`createEntry`, `createEntryBatch`) - Fully atomic, no race conditions
- **Read operations** (like reading entries) use read locks
- **Write operations** (like appending entries) use write locks
- **Multiple readers** can access simultaneously
- **Writers have exclusive access**
- **Sequence number generation** is atomic and thread-safe
- **Metadata management** is fully encapsulated and automatic

## Performance Considerations

- **Binary format** is more efficient than Java serialization
- **CRC32 checksums** provide fast integrity verification
- **Batch operations** are more efficient than individual operations
- **Atomic entry creation** eliminates coordination overhead between threads
- **Consistent sync behavior** - both log and sequence files respect `syncOnWrite` flag
- **Efficient sequence file management** - keeps sequence file open to avoid repeated open/close operations
- **File rotation** prevents individual files from becoming too large
- **Sequence-based size calculation** provides O(1) size operations without separate counting
- **Sequence number persistence** ensures consistency across restarts
- **Automatic metadata management** eliminates manual coordination overhead

## Recovery Guarantees

- All successfully written entries are recoverable after restart
- CRC32 checksums detect and skip corrupted entries during recovery
- Sequence numbers are properly recovered and always increment
- Entry counts are accurately maintained
- Sequence number persistence ensures no duplicates after restart
- **Thread-safe recovery** - Multiple threads can safely access WAL after restart
- **Automatic metadata recovery** - Sequence numbers and timestamps are properly restored

## Design Philosophy

This WAL implementation follows the principle of being **clean, efficient, thread-safe, and well-encapsulated**:

- **POJO-based entries** - no serialization dependencies in the data model
- **Binary format** - efficient storage and fast I/O
- **CRC32 validation** - fast and reliable integrity checking
- **Generic record types** - users define their own operation types
- **Transaction-aware** - built-in support for transaction operations
- **ByteBuffer support** - efficient handling of binary data
- **Immutable entries** - defensive copying ensures data integrity
- **Atomic operations** - eliminates race conditions in multi-threaded environments
- **Comprehensive batch support** - efficient bulk operations
- **Automatic metadata management** - WAL handles all sequence numbers and timestamps
- **Clean encapsulation** - no way for users to corrupt internal state

## API Summary

### WALManager (High-Level API)

**Thread-Safe Entry Creation:**
```java
WALEntry createEntry(byte[] data)                           // Single entry
WALEntry createEntry(ByteBuffer data)                       // Single entry
List<WALEntry> createEntryBatch(List<ByteBuffer> dataList)  // Batch entries
List<WALEntry> createEntryBatchFromBytes(List<byte[]> data) // Batch entries (convenience)
```

**Reading and Management:**
```java
List<WALEntry> readFrom(long fromSequenceNumber)
List<WALEntry> readRange(long from, long to)
List<WALEntry> readFrom(Instant fromTimestamp)
List<WALEntry> readRange(Instant fromTimestamp, Instant toTimestamp)
void sync()
void truncate(long upToSequenceNumber)
long getCurrentSequenceNumber()
long getNextSequenceNumber()  // For informational purposes only
long size()
boolean isEmpty()
```

### FileBasedWAL (Low-Level API)

**Atomic Operations:**
```java
WALEntry createAndAppend(ByteBuffer data)                      // Thread-safe single
List<WALEntry> createAndAppendBatch(List<ByteBuffer> dataList) // Thread-safe batch
```

## Key Benefits

- **🔒 Thread Safety**: Full concurrency support with no race conditions
- **⚡ Performance**: Optimized binary format and batch operations
- **🛡️ Data Integrity**: CRC32 checksums and atomic operations
- **🔄 Recovery**: Automatic crash recovery with sequence number persistence
- **🧹 Clean API**: Encapsulated metadata management prevents corruption
- **📈 Scalability**: Efficient file rotation and concurrent access
- **🎯 Simplicity**: Easy-to-use API with automatic sequence and timestamp management

This implementation provides a solid foundation for building reliable database systems that require strong durability guarantees, **thread safety**, and high performance while maintaining clean architecture and comprehensive test coverage.

## TODO

- **Recovery from old logs** - Smarter implementation of recovery from rotated WAL files
- **Prevent tampering with cryptographic mechanisms** - Add cryptographic signatures or checksums to prevent unauthorized modification of WAL entries